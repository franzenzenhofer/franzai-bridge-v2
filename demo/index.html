<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>FranzAI Bridge V2 - Complete Feature Demo</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #0a0a0a;
      color: #e0e0e0;
      line-height: 1.6;
      padding: 20px;
    }
    h1 { color: #ff6b35; margin-bottom: 10px; }
    h2 { color: #4ecdc4; margin: 20px 0 10px; border-bottom: 1px solid #333; padding-bottom: 5px; }
    .header { text-align: center; margin-bottom: 30px; }
    .status-bar {
      background: #1a1a1a;
      border: 1px solid #333;
      border-radius: 8px;
      padding: 15px;
      margin-bottom: 20px;
      display: flex;
      gap: 20px;
      flex-wrap: wrap;
    }
    .status-item { display: flex; align-items: center; gap: 8px; }
    .status-dot {
      width: 12px; height: 12px;
      border-radius: 50%;
      background: #666;
    }
    .status-dot.success { background: #4ecdc4; }
    .status-dot.error { background: #ff6b6b; }
    .status-dot.pending { background: #ffd93d; animation: pulse 1s infinite; }
    @keyframes pulse { 50% { opacity: 0.5; } }

    .grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(400px, 1fr)); gap: 20px; }
    .card {
      background: #1a1a1a;
      border: 1px solid #333;
      border-radius: 8px;
      padding: 15px;
    }
    .card h3 { color: #ff6b35; margin-bottom: 10px; font-size: 14px; }
    button {
      background: #ff6b35;
      color: white;
      border: none;
      padding: 8px 16px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      margin: 5px 5px 5px 0;
    }
    button:hover { background: #e55a2b; }
    button:disabled { background: #666; cursor: not-allowed; }
    button.secondary { background: #4ecdc4; }
    button.secondary:hover { background: #3dbdb4; }

    .result {
      background: #0d0d0d;
      border: 1px solid #333;
      border-radius: 4px;
      padding: 10px;
      margin-top: 10px;
      font-family: 'Monaco', 'Menlo', monospace;
      font-size: 12px;
      max-height: 200px;
      overflow-y: auto;
      white-space: pre-wrap;
      word-break: break-all;
    }
    .result.success { border-color: #4ecdc4; }
    .result.error { border-color: #ff6b6b; color: #ff6b6b; }

    .test-row {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 8px 0;
      border-bottom: 1px solid #222;
    }
    .test-row:last-child { border-bottom: none; }
    .test-name { flex: 1; }
    .test-status { font-weight: bold; }
    .test-status.pass { color: #4ecdc4; }
    .test-status.fail { color: #ff6b6b; }
    .test-status.running { color: #ffd93d; }

    .summary {
      background: #1a1a1a;
      border: 2px solid #4ecdc4;
      border-radius: 8px;
      padding: 20px;
      margin-top: 30px;
      text-align: center;
    }
    .summary h2 { border: none; }
    .summary .count { font-size: 48px; font-weight: bold; color: #4ecdc4; }
    .summary .label { color: #888; }

    input, select {
      background: #0d0d0d;
      border: 1px solid #333;
      color: #e0e0e0;
      padding: 8px;
      border-radius: 4px;
      margin: 5px 0;
    }
  </style>
</head>
<body>
  <div class="header">
    <h1>FranzAI Bridge V2 - Complete Feature Demo</h1>
    <p>Testing all extension functions: CORS bypass, API injection, modes, and more</p>
    <p style="margin-top: 10px;"><a href="simple-test.html" style="color: #4ecdc4;">â†’ Simple Extension Detection Test</a></p>
  </div>

  <div class="status-bar" id="statusBar">
    <div class="status-item">
      <div class="status-dot" id="extensionStatus"></div>
      <span>Extension: <span id="extensionText">Checking...</span></span>
    </div>
    <div class="status-item">
      <div class="status-dot" id="bridgeStatus"></div>
      <span>Bridge: <span id="bridgeText">Checking...</span></span>
    </div>
    <div class="status-item">
      <div class="status-dot" id="modeStatus"></div>
      <span>Mode: <span id="modeText">Unknown</span></span>
    </div>
  </div>

  <div class="grid">
    <div class="card">
      <h3>1. Extension Detection</h3>
      <button onclick="testExtensionDetection()">Test Detection</button>
      <button onclick="testPing()" class="secondary">Ping Bridge</button>
      <div class="result" id="detectionResult">Click a button to test...</div>
    </div>

    <div class="card">
      <h3>2. Mode Control (auto/always/off)</h3>
      <button onclick="setMode('auto')">Set Auto</button>
      <button onclick="setMode('always')">Set Always</button>
      <button onclick="setMode('off')">Set Off</button>
      <button onclick="getMode()" class="secondary">Get Current</button>
      <div class="result" id="modeResult">Current mode will appear here...</div>
    </div>

    <div class="card">
      <h3>3. Same-Origin Fetch</h3>
      <button onclick="testSameOrigin()">Test Same-Origin</button>
      <div class="result" id="sameOriginResult">Click to test same-origin fetch...</div>
    </div>

    <div class="card">
      <h3>4. Cross-Origin CORS Bypass</h3>
      <button onclick="testCorsHttpbin()">Test httpbin.org</button>
      <button onclick="testCorsJsonPlaceholder()" class="secondary">Test jsonplaceholder</button>
      <div class="result" id="corsResult">Click to test CORS bypass...</div>
    </div>

    <div class="card">
      <h3>5. OpenAI API (with key injection)</h3>
      <button onclick="testOpenAI()">Test OpenAI Models</button>
      <div class="result" id="openaiResult">Requires OPENAI_API_KEY in extension settings...</div>
    </div>

    <div class="card">
      <h3>6. Google Gemini API (with key injection)</h3>
      <button onclick="testGemini()">Test Gemini Models</button>
      <div class="result" id="geminiResult">Requires GOOGLE_API_KEY in extension settings...</div>
    </div>

    <div class="card">
      <h3>7. HTTP Methods (GET/POST/PUT/DELETE)</h3>
      <button onclick="testMethod('GET')">GET</button>
      <button onclick="testMethod('POST')">POST</button>
      <button onclick="testMethod('PUT')">PUT</button>
      <button onclick="testMethod('DELETE')">DELETE</button>
      <div class="result" id="methodsResult">Test different HTTP methods...</div>
    </div>

    <div class="card">
      <h3>8. Request Body Types</h3>
      <button onclick="testBodyType('json')">JSON</button>
      <button onclick="testBodyType('text')">Text</button>
      <button onclick="testBodyType('form')">FormData</button>
      <div class="result" id="bodyResult">Test different body types...</div>
    </div>

    <div class="card">
      <h3>9. Custom Headers</h3>
      <button onclick="testCustomHeaders()">Test Custom Headers</button>
      <div class="result" id="headersResult">Test custom header passing...</div>
    </div>

    <div class="card">
      <h3>10. Abort Signal / Timeout</h3>
      <button onclick="testAbort()">Test Abort (100ms)</button>
      <div class="result" id="abortResult">Test request cancellation...</div>
    </div>

    <div class="card">
      <h3>11. Error Handling (4xx/5xx)</h3>
      <button onclick="testError(404)">Test 404</button>
      <button onclick="testError(500)">Test 500</button>
      <div class="result" id="errorResult">Test error response handling...</div>
    </div>

    <div class="card">
      <h3>12. Response Types</h3>
      <button onclick="testResponseType('json')">JSON Response</button>
      <button onclick="testResponseType('text')">Text Response</button>
      <button onclick="testResponseType('html')">HTML Response</button>
      <div class="result" id="responseResult">Test different response types...</div>
    </div>
  </div>

  <h2>Automated Test Suite</h2>
  <button onclick="runAllTests()" id="runAllBtn">Run All Tests</button>
  <button onclick="clearResults()" class="secondary">Clear Results</button>

  <div id="testResults" style="margin-top: 20px;"></div>

  <div class="summary" id="summary" style="display: none;">
    <h2>Test Results</h2>
    <div class="count" id="summaryCount">0/0</div>
    <div class="label">Tests Passed</div>
  </div>

  <script>
    // NOTE: Don't cache franzai here - it gets injected after page load!
    // Always use window.franzai directly
    let testsRun = 0;
    let testsPassed = 0;

    function updateStatus() {
      console.log('[Demo] updateStatus called, window.franzai =', typeof window.franzai);
      const extStatus = document.getElementById('extensionStatus');
      const extText = document.getElementById('extensionText');
      const bridgeStatus = document.getElementById('bridgeStatus');
      const bridgeText = document.getElementById('bridgeText');
      const modeStatus = document.getElementById('modeStatus');
      const modeText = document.getElementById('modeText');

      if (typeof window.franzai !== 'undefined') {
        console.log('[Demo] Extension FOUND! Version:', window.franzai.version);
        extStatus.classList.remove('error', 'pending');
        extStatus.classList.add('success');
        extText.textContent = 'v' + window.franzai.version;
        bridgeStatus.classList.remove('error', 'pending');
        bridgeStatus.classList.add('success');
        bridgeText.textContent = 'Ready';
        modeStatus.classList.remove('pending');
        modeStatus.classList.add('success');
        modeText.textContent = window.franzai.getMode();
        // Update page title with version
        document.title = 'FranzAI Bridge V2 v' + window.franzai.version + ' - Demo';
      } else {
        console.log('[Demo] Extension NOT found yet');
        extStatus.classList.add('error');
        extText.textContent = 'Not Found';
        bridgeStatus.classList.add('error');
        bridgeText.textContent = 'Unavailable';
      }
    }

    function showResult(elementId, success, message) {
      const el = document.getElementById(elementId);
      el.textContent = typeof message === 'object' ? JSON.stringify(message, null, 2) : message;
      el.className = 'result ' + (success ? 'success' : 'error');
    }

    async function testExtensionDetection() {
      if (typeof window.franzai !== 'undefined') {
        showResult('detectionResult', true, {
          detected: true,
          version: window.franzai.version,
          mode: window.franzai.getMode(),
          hasFetch: typeof window.franzai.fetch === 'function',
          hasPing: typeof window.franzai.ping === 'function',
          hasSetMode: typeof window.franzai.setMode === 'function',
          hasGetMode: typeof window.franzai.getMode === 'function'
        });
      } else {
        showResult('detectionResult', false, 'Extension not detected! Make sure FranzAI Bridge is installed and this origin is allowed.');
      }
    }

    async function testPing() {
      if (!window.franzai) { showResult('detectionResult', false, 'Extension not available'); return; }
      try {
        const result = await window.franzai.ping();
        showResult('detectionResult', true, result);
      } catch (e) { showResult('detectionResult', false, e.message); }
    }

    function setMode(mode) {
      if (!window.franzai) { showResult('modeResult', false, 'Extension not available'); return; }
      try {
        const result = window.franzai.setMode(mode);
        showResult('modeResult', true, 'Mode set to: ' + result);
        updateStatus();
      } catch (e) { showResult('modeResult', false, e.message); }
    }

    function getMode() {
      if (!window.franzai) { showResult('modeResult', false, 'Extension not available'); return; }
      try {
        const mode = window.franzai.getMode();
        showResult('modeResult', true, 'Current mode: ' + mode);
      } catch (e) { showResult('modeResult', false, e.message); }
    }

    async function testSameOrigin() {
      try {
        const response = await fetch(window.location.href);
        showResult('sameOriginResult', true, { status: response.status, ok: response.ok, type: 'same-origin' });
      } catch (e) { showResult('sameOriginResult', false, e.message); }
    }

    async function testCorsHttpbin() {
      try {
        const response = await fetch('https://httpbin.org/get');
        const data = await response.json();
        showResult('corsResult', true, { status: response.status, ok: response.ok, origin: data.origin, url: data.url });
      } catch (e) { showResult('corsResult', false, 'CORS Error: ' + e.message); }
    }

    async function testCorsJsonPlaceholder() {
      try {
        const response = await fetch('https://jsonplaceholder.typicode.com/posts/1');
        const data = await response.json();
        showResult('corsResult', true, { status: response.status, ok: response.ok, data: data });
      } catch (e) { showResult('corsResult', false, 'Error: ' + e.message); }
    }

    async function testOpenAI() {
      try {
        const response = await fetch('https://api.openai.com/v1/models', { headers: { 'Content-Type': 'application/json' } });
        if (response.status === 200) {
          const data = await response.json();
          showResult('openaiResult', true, { status: response.status, modelCount: data.data?.length || 0 });
        } else if (response.status === 401) {
          showResult('openaiResult', false, 'API key not configured or invalid. Add OPENAI_API_KEY in extension settings.');
        } else {
          showResult('openaiResult', false, 'Status: ' + response.status + ' - ' + response.statusText);
        }
      } catch (e) { showResult('openaiResult', false, e.message); }
    }

    async function testGemini() {
      try {
        const response = await fetch('https://generativelanguage.googleapis.com/v1/models', { headers: { 'Content-Type': 'application/json' } });
        if (response.status === 200) {
          const data = await response.json();
          showResult('geminiResult', true, { status: response.status, modelCount: data.models?.length || 0 });
        } else {
          showResult('geminiResult', false, 'API key not configured. Add GOOGLE_API_KEY in extension settings.');
        }
      } catch (e) { showResult('geminiResult', false, e.message); }
    }

    async function testMethod(method) {
      try {
        const options = { method };
        if (method === 'POST' || method === 'PUT') {
          options.headers = { 'Content-Type': 'application/json' };
          options.body = JSON.stringify({ test: 'data', method: method });
        }
        const response = await fetch('https://httpbin.org/' + method.toLowerCase(), options);
        const data = await response.json();
        showResult('methodsResult', true, { method: method, status: response.status, receivedMethod: data.method || method });
      } catch (e) { showResult('methodsResult', false, e.message); }
    }

    async function testBodyType(type) {
      try {
        let body, contentType;
        if (type === 'json') { body = JSON.stringify({ type: 'json', data: [1, 2, 3] }); contentType = 'application/json'; }
        else if (type === 'text') { body = 'Hello, this is plain text body!'; contentType = 'text/plain'; }
        else if (type === 'form') { body = new URLSearchParams({ name: 'test', value: '123' }); contentType = 'application/x-www-form-urlencoded'; }
        const response = await fetch('https://httpbin.org/post', { method: 'POST', headers: { 'Content-Type': contentType }, body: body });
        const data = await response.json();
        showResult('bodyResult', true, { type: type, status: response.status, receivedData: data.data || data.form || data.json });
      } catch (e) { showResult('bodyResult', false, e.message); }
    }

    async function testCustomHeaders() {
      try {
        const response = await fetch('https://httpbin.org/headers', { headers: { 'X-Custom-Header': 'custom-value-123', 'X-Another-Header': 'another-value' } });
        const data = await response.json();
        showResult('headersResult', true, { status: response.status, customHeader: data.headers['X-Custom-Header'], anotherHeader: data.headers['X-Another-Header'] });
      } catch (e) { showResult('headersResult', false, e.message); }
    }

    async function testAbort() {
      const controller = new AbortController();
      setTimeout(function() { controller.abort(); }, 100);
      try {
        await fetch('https://httpbin.org/delay/5', { signal: controller.signal });
        showResult('abortResult', false, 'Request should have been aborted!');
      } catch (e) {
        if (e.name === 'AbortError') {
          showResult('abortResult', true, { success: true, errorName: e.name, message: 'Request successfully aborted after 100ms' });
        } else { showResult('abortResult', false, e.message); }
      }
    }

    async function testError(statusCode) {
      try {
        const response = await fetch('https://httpbin.org/status/' + statusCode);
        showResult('errorResult', true, { status: response.status, ok: response.ok, statusText: response.statusText, isError: !response.ok });
      } catch (e) { showResult('errorResult', false, e.message); }
    }

    async function testResponseType(type) {
      try {
        let url;
        if (type === 'json') url = 'https://httpbin.org/json';
        else if (type === 'text') url = 'https://httpbin.org/robots.txt';
        else if (type === 'html') url = 'https://httpbin.org/html';
        const response = await fetch(url);
        const contentType = response.headers.get('content-type');
        let data;
        if (contentType && contentType.indexOf('json') !== -1) data = await response.json();
        else data = (await response.text()).substring(0, 200);
        showResult('responseResult', true, { type: type, contentType: contentType, status: response.status, preview: data });
      } catch (e) { showResult('responseResult', false, e.message); }
    }

    const tests = [
      { name: 'Extension Detection', fn: async function() { return typeof window.franzai !== 'undefined'; } },
      { name: 'Ping Bridge', fn: async function() { const r = await window.franzai.ping(); return r.ok; } },
      { name: 'Get Mode', fn: async function() { return ['auto', 'always', 'off'].indexOf(window.franzai.getMode()) !== -1; } },
      { name: 'Set Mode (always)', fn: async function() { return window.franzai.setMode('always') === 'always'; } },
      { name: 'Set Mode (auto)', fn: async function() { return window.franzai.setMode('auto') === 'auto'; } },
      { name: 'CORS - httpbin GET', fn: async function() { const r = await fetch('https://httpbin.org/get'); return r.ok; } },
      { name: 'CORS - httpbin POST', fn: async function() { const r = await fetch('https://httpbin.org/post', { method: 'POST', body: 'test' }); return r.ok; } },
      { name: 'JSON Response Parsing', fn: async function() { const r = await fetch('https://httpbin.org/json'); const d = await r.json(); return typeof d === 'object'; } },
      { name: 'Custom Headers', fn: async function() { const r = await fetch('https://httpbin.org/headers', { headers: { 'X-Test': 'value' }}); const d = await r.json(); return d.headers['X-Test'] === 'value'; } },
      { name: 'HTTP 404 Handling', fn: async function() { const r = await fetch('https://httpbin.org/status/404'); return r.status === 404; } },
      { name: 'HTTP 500 Handling', fn: async function() { const r = await fetch('https://httpbin.org/status/500'); return r.status === 500; } },
      { name: 'Abort Signal', fn: async function() { const c = new AbortController(); setTimeout(function() { c.abort(); }, 50); try { await fetch('https://httpbin.org/delay/5', { signal: c.signal }); return false; } catch(e) { return e.name === 'AbortError'; } } },
      { name: 'URLSearchParams Body', fn: async function() { const p = new URLSearchParams({a:'1'}); const r = await fetch('https://httpbin.org/post', { method: 'POST', body: p }); return r.ok; } },
    ];

    function createTestRow(testName) {
      const row = document.createElement('div');
      row.className = 'test-row';
      const nameSpan = document.createElement('span');
      nameSpan.className = 'test-name';
      nameSpan.textContent = testName;
      const statusSpan = document.createElement('span');
      statusSpan.className = 'test-status running';
      statusSpan.textContent = 'Running...';
      row.appendChild(nameSpan);
      row.appendChild(statusSpan);
      return row;
    }

    async function runAllTests() {
      const btn = document.getElementById('runAllBtn');
      btn.disabled = true;
      btn.textContent = 'Running...';

      testsRun = 0;
      testsPassed = 0;
      const container = document.getElementById('testResults');
      while (container.firstChild) container.removeChild(container.firstChild);

      for (let i = 0; i < tests.length; i++) {
        const test = tests[i];
        const row = createTestRow(test.name);
        container.appendChild(row);
        const statusSpan = row.querySelector('.test-status');

        try {
          const result = await test.fn();
          testsRun++;
          if (result) {
            testsPassed++;
            statusSpan.textContent = 'PASS';
            statusSpan.className = 'test-status pass';
          } else {
            statusSpan.textContent = 'FAIL';
            statusSpan.className = 'test-status fail';
          }
        } catch (e) {
          testsRun++;
          statusSpan.textContent = 'FAIL: ' + e.message.substring(0, 30);
          statusSpan.className = 'test-status fail';
        }
      }

      const summary = document.getElementById('summary');
      summary.style.display = 'block';
      document.getElementById('summaryCount').textContent = testsPassed + '/' + testsRun;
      summary.style.borderColor = testsPassed === testsRun ? '#4ecdc4' : '#ff6b6b';

      btn.disabled = false;
      btn.textContent = 'Run All Tests';
    }

    function clearResults() {
      const container = document.getElementById('testResults');
      while (container.firstChild) container.removeChild(container.firstChild);
      document.getElementById('summary').style.display = 'none';
      const results = document.querySelectorAll('.result');
      for (let i = 0; i < results.length; i++) {
        results[i].textContent = 'Click a button to test...';
        results[i].className = 'result';
      }
    }

    // Wait for extension to inject (content script needs time)
    console.log('[Demo] Page loaded, waiting for extension...');

    function waitForExtension(maxAttempts, attempt) {
      attempt = attempt || 0;
      console.log('[Demo] Check attempt', attempt + 1, '/', maxAttempts, '- window.franzai:', typeof window.franzai);

      if (typeof window.franzai !== 'undefined') {
        console.log('[Demo] Extension detected on attempt', attempt + 1);
        updateStatus();
        return;
      }
      if (attempt < maxAttempts) {
        setTimeout(function() { waitForExtension(maxAttempts, attempt + 1); }, 100);
      } else {
        console.log('[Demo] Extension not found after', maxAttempts, 'attempts');
        updateStatus(); // Show "not found" after all attempts
      }
    }

    // Start checking after small delay (like simple-test.html)
    setTimeout(function() { waitForExtension(30); }, 100);

    // Also check again after full page load
    window.addEventListener('load', function() {
      console.log('[Demo] Window load event fired');
      setTimeout(function() {
        if (typeof window.franzai !== 'undefined') {
          console.log('[Demo] Extension found on load event');
          updateStatus();
        }
      }, 500);
    });
  </script>
</body>
</html>
